---
title: File system
date: 2025-02-11
author: toshio
tags: 
---

Canisterにデータを格納するために、まずは既存のファイルシステムを調査する。

## ext4やXFS

ext4やXFSなどのファイルシステムは、以下のような要素で構成されています。

*   **ブートブロック:** ファイルシステムの情報を格納する領域。
*   **スーパーブロック:** ファイルシステム全体の設定情報（ブロックサイズ、inode数など）を格納する領域。
*   **inode:** ファイルやディレクトリのメタデータ（所有者、パーミッション、サイズ、データブロックの場所など）を格納する領域。
*   **データブロック:** ファイルの実際のデータを格納する領域。
*   **ディレクトリ:** ファイルやディレクトリを階層的に管理するための仕組み。

### ext4

https://qiita.com/kamihork/items/fbcd116a631324aae05d

> - fourth extended file system」の略で、現在のLinuxファイルシステムのデファクトスタンダード
> - 最大ファイルサイズは16TiB, 最大ボリュームサイズは1EiB
> - 日付範囲も1901年12月14日から2514年4月25日まで

### ブートブロック

ブートブロックは、通常、ディスクの最初のセクタ（512バイト）に位置し、以下の情報を格納します。

*   **ブートストラップコード:** OSを起動するためのプログラム。
*   **パーティションテーブル:** ディスクが複数のパーティションに分割されている場合、各パーティションの情報（開始セクタ、サイズなど）を格納します。

→Canisterには不要

### スーパーブロック

スーパーブロックは、ext4ファイルシステムに関する様々な情報を格納する領域です。スーパーブロックには、以下の情報が含まれます。

*   **マジックナンバー:** ファイルシステムの種類を識別するための番号。ext4の場合は、0xEF53。
*   **ブロックサイズ:** データブロックのサイズ。通常は、1KB、2KB、4KBなど。
*   **inode数:** ファイルやディレクトリの数を格納する領域。
*   **inodeサイズ:** inodeのサイズ。
*   **その他の設定情報:** ファイルシステムのバージョン、作成日時、最終マウント日時など。

### 

ext4のスーパーブロックのC言語の構造体は、Linuxカーネルのソースコードで確認できます。

具体的には、以下のファイルに定義されています。

- fs/ext4/ext4.h

このファイルには、ext4_super_blockという構造体が定義されており、ext4ファイルシステムのスーパーブロックの構造が記述されています。

https://github.com/torvalds/linux/blob/v6.13/fs/ext4/ext4.h#L1304

```c:fs/ext4/ext4.h
struct ext4_super_block {
    __le32  s_magic;        /* Magic number */
    __le32  s_inode_count;      /* Inode count */
    __le32  s_block_count_hi;   /* Block count high 32bits */
    __le32  s_r_blocks_count_hi; /* Reserved block count high 32bits */
    __le32  s_free_blocks_count_hi; /* Free block count high 32bits */
    __le32  s_free_inodes_count;    /* Free inode count */
    __le32  s_first_data_block; /* First Data Block */
    __le32  s_log_block_size;     /* Block size in bits */
    __le32  s_log_frag_size;    /* Fragment size in bits */
    /* ... other fields ... */
};
```

→バージョン情報等は必要。


## i-nodeの詳細

i-nodeは、ファイルシステムにおいて非常に重要な役割を果たしています。

*   **ファイルのメタデータを管理:** ファイル名以外のほとんどのファイル情報はi-nodeに格納されています。
*   **データブロックへのポインタ:** i-nodeは、ファイルがどのデータブロックに格納されているかを指し示すポインタを持っています。
*   **ファイルの種類:** i-nodeは、ファイルの種類（通常ファイル、ディレクトリ、シンボリックリンクなど）を識別するための情報を持っています。
*   **アクセス権限:** i-nodeは、ファイルのアクセス権限（読み取り、書き込み、実行）を管理しています。
*   **タイムスタンプ:** i-nodeは、ファイルの作成日時、最終アクセス日時、最終変更日時などのタイムスタンプを管理しています。


### 
https://qiita.com/kamihork/items/fbcd116a631324aae05d

- i-nodeはファイルシステムにおけるデータ構造のことで、index-nodeの略
- 1ファイル、1ディレクトリごとにi-nodeテーブルの1エントリが使用され、1:1対応の管理情報のことを指す
- i-node内には、以下のような情報が保存され、それぞれのi-nodeにはiナンバというユニークな識別番号が付与される
  - ファイルの長さ（バイト数）
  - デバイスID（ファイルを格納しているデバイスを識別）ファイル所有者のユーザーID
  - ファイルのグループID
  - ファイルシステム内でファイルを識別する inode 番号
  - ファイルモード（ファイルパーミッション）
  - 最終inode更新時(ctime)、最終ファイル更新時(mtime)、最終参照時(atime) を示すタイムスタンプ群
  - そのinodeを指すハードリンクがいくつあるかを示す参照カウント
  - i-nodeはファイルの属性を管理するがファイル名に関しては別のリストで管理されている

→ハッシュ値は必要
→ハッシュ値に対する署名も必要
→署名元データはどこか

### Linuxシステム

https://www.kernel.org/doc/html/latest/filesystems/ext4/inodes.html

## ファイルシステム開発のステップ

1.  **ファイルシステムの設計:** どのような機能を持つファイルシステムを作成するか、ブロックサイズやinode数などを決定します。
2.  **データ構造の実装:** スーパーブロック、inode、データブロックなどのデータ構造をRustで実装します。
3.  **ファイル操作の実装:** ファイルの作成、読み込み、書き込み、削除などの操作を実装します。
4.  **ディレクトリ構造の実装:** ディレクトリの作成、移動、削除などの操作を実装します。
5.  **テスト:** 作成したファイルシステムが正しく動作するかテストします。
